Index: lab1/src/main/java/simpledb/storage/TupleDesc.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package simpledb.storage;\r\n\r\nimport simpledb.common.Type;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Arrays;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\n/**\r\n * TupleDesc describes the schema of a tuple.\r\n */\r\npublic class TupleDesc implements Serializable {\r\n\r\n    public final TDItem[] tdItems;\r\n\r\n\r\n    /**\r\n     * A help class to facilitate organizing the information of each field\r\n     */\r\n    public static class TDItem implements Serializable {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        /**\r\n         * The type of the field\r\n         */\r\n        public final Type fieldType;\r\n\r\n        /**\r\n         * The name of the field\r\n         */\r\n        public final String fieldName;\r\n\r\n        public TDItem(Type t, String n) {\r\n            this.fieldName = n;\r\n            this.fieldType = t;\r\n        }\r\n\r\n        public String toString() {\r\n            return fieldName + \"(\" + fieldType + \")\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return An iterator which iterates over all the field TDItems\r\n     *         that are included in this TupleDesc\r\n     */\r\n    public Iterator<TDItem> iterator() {\r\n        if(tdItems == null) {\r\n            return null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * Create a new TupleDesc with typeAr.length fields with fields of the\r\n     * specified types, with associated named fields.\r\n     *\r\n     * @param typeAr  array specifying the number of and types of fields in this\r\n     *                TupleDesc. It must contain at least one entry.\r\n     * @param fieldAr array specifying the names of the fields. Note that names may\r\n     *                be null.\r\n     */\r\n    public TupleDesc(Type[] typeAr, String[] fieldAr) {\r\n        int len = typeAr.length;\r\n        tdItems = new TDItem[len];\r\n        for(int i = 0; i < len; i++){\r\n            TDItem tdItem = new TDItem(typeAr[i], fieldAr[i]);\r\n            tdItems[i] = tdItem;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor. Create a new tuple desc with typeAr.length fields with\r\n     * fields of the specified types, with anonymous (unnamed) fields.\r\n     *\r\n     * @param typeAr array specifying the number of and types of fields in this\r\n     *               TupleDesc. It must contain at least one entry.\r\n     */\r\n    public TupleDesc(Type[] typeAr) {\r\n        // TODO: some code goes here\r\n        int len = typeAr.length;\r\n        tdItems = new TDItem[len];\r\n        for(int i = 0; i < len ; i++){\r\n            TDItem tdItem = new TDItem(typeAr[i], \"\");\r\n            tdItems[i] = tdItem;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the number of fields in this TupleDesc\r\n     */\r\n    public int numFields() {\r\n        return tdItems.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the (possibly null) field name of the ith field of this TupleDesc.\r\n     *\r\n     * @param i index of the field name to return. It must be a valid index.\r\n     * @return the name of the ith field\r\n     * @throws NoSuchElementException if i is not a valid field reference.\r\n     */\r\n    public String getFieldName(int i) throws NoSuchElementException {\r\n        if(i < 0 || i > tdItems.length-1){\r\n            throw new NoSuchElementException(\"i is not a valid index\");\r\n        }\r\n        return tdItems[i].fieldName;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of the ith field of this TupleDesc.\r\n     *\r\n     * @param i The index of the field to get the type of. It must be a valid\r\n     *          index.\r\n     * @return the type of the ith field\r\n     * @throws NoSuchElementException if i is not a valid field reference.\r\n     */\r\n    public Type getFieldType(int i) throws NoSuchElementException {\r\n        if(i < 0 || i > tdItems.length-1){\r\n            throw new NoSuchElementException(\"i is not a legal index\");\r\n        }\r\n        return tdItems[i].fieldType;\r\n    }\r\n\r\n    /**\r\n     * Find the index of the field with a given name.\r\n     *\r\n     * @param name name of the field.\r\n     * @return the index of the field that is first to have the given name.\r\n     * @throws NoSuchElementException if no field with a matching name is found.\r\n     */\r\n    public int indexForFieldName(String name) throws NoSuchElementException {\r\n        if(name == null){\r\n            throw new NoSuchElementException(\"name is null\");\r\n        }\r\n        for(int i = 0; i < tdItems.length; i++){\r\n            if(name.equals(tdItems[i].fieldName)){\r\n                return i;\r\n            }\r\n        }\r\n        throw  new NoSuchElementException(\"No such Element\");\r\n    }\r\n\r\n    /**\r\n     * @return The size (in bytes) of tuples corresponding to this TupleDesc.\r\n     *         Note that tuples from a given TupleDesc are of a fixed size.\r\n     */\r\n    public int getSize() {\r\n        // TODO: some code goes here\r\n        int size = 0;\r\n        for(TDItem item: tdItems){\r\n            int len = item.fieldType.getLen();\r\n            size += len;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Merge two TupleDescs into one, with td1.numFields + td2.numFields fields,\r\n     * with the first td1.numFields coming from td1 and the remaining from td2.\r\n     *\r\n     * @param td1 The TupleDesc with the first fields of the new TupleDesc\r\n     * @param td2 The TupleDesc with the last fields of the TupleDesc\r\n     * @return the new TupleDesc\r\n     */\r\n    public static TupleDesc merge(TupleDesc td1, TupleDesc td2) {\r\n        int l1 = td1.numFields();\r\n        int l2 = td2.numFields();\r\n        int len = td1.numFields() + td2.numFields();\r\n        Type[] types = new Type[len];\r\n        String[] names = new String[len];\r\n        for(int i = 0; i < len; i++){\r\n            if(i < td1.numFields()){\r\n                types[i] = td1.tdItems[i].fieldType;\r\n                names[i] = td1.tdItems[i].fieldName;\r\n            }else {\r\n                types[i] = td2.tdItems[i-l1].fieldType;\r\n                names[i] = td2.tdItems[i-l1].fieldName;\r\n            }\r\n        }\r\n        return new TupleDesc(types,names);\r\n    }\r\n\r\n    /**\r\n     * Compares the specified object with this TupleDesc for equality. Two\r\n     * TupleDescs are considered equal if they have the same number of items\r\n     * and if the i-th type in this TupleDesc is equal to the i-th type in o\r\n     * for every i.\r\n     *\r\n     * @param o the Object to be compared for equality with this TupleDesc.\r\n     * @return true if the object is equal to this TupleDesc.\r\n     */\r\n\r\n    public boolean equals(Object o) {\r\n        if (o == null){\r\n            return false;\r\n        }\r\n        if(this.getClass() != o.getClass()){\r\n            return false;\r\n        }\r\n        if(tdItems.length != ((TupleDesc)o).tdItems.length){\r\n            return false;\r\n        }else{\r\n            TDItem[] oitems = ((TupleDesc) o).tdItems;\r\n            for(int i = 0; i < tdItems.length; i++){\r\n                if(!tdItems[i].fieldType.equals(oitems[i].fieldType) || !tdItems[i].fieldName.equals(oitems[i].fieldName)){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public int hashCode() {\r\n        // If you want to use TupleDesc as keys for HashMap, implement this so\r\n        // that equal objects have equals hashCode() results\r\n        int result = 0;\r\n        for (TDItem item : tdItems) {\r\n            result += item.toString().hashCode() * 41 ;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a String describing this descriptor. It should be of the form\r\n     * \"fieldType[0](fieldName[0]), ..., fieldType[M](fieldName[M])\", although\r\n     * the exact format does not matter.\r\n     *\r\n     * @return String describing this descriptor.\r\n     */\r\n    public String toString() {\r\n        StringBuilder builder = new StringBuilder();\r\n        for(int i = 0; i < tdItems.length; i++){\r\n            if(i == tdItems.length-1){\r\n                builder.append(tdItems[i].fieldType).append(\"(\").append(tdItems[i].fieldName).append(\")\");\r\n                continue;\r\n            }\r\n            builder.append(tdItems[i].fieldType).append(\"(\").append(tdItems[i].fieldName).append(\")\").append(\",\");\r\n        }\r\n        return builder.toString();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab1/src/main/java/simpledb/storage/TupleDesc.java b/lab1/src/main/java/simpledb/storage/TupleDesc.java
--- a/lab1/src/main/java/simpledb/storage/TupleDesc.java	(revision 9d1d44076b18d9703028e44e0dbc603f533de95a)
+++ b/lab1/src/main/java/simpledb/storage/TupleDesc.java	(date 1669553210474)
@@ -47,10 +47,7 @@
      *         that are included in this TupleDesc
      */
     public Iterator<TDItem> iterator() {
-        if(tdItems == null) {
-            return null;
-        }
-        return null;
+        return Arrays.asList(tdItems).iterator();
     }
 
     private static final long serialVersionUID = 1L;
Index: lab1/src/main/java/simpledb/utils/LRUCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab1/src/main/java/simpledb/utils/LRUCache.java b/lab1/src/main/java/simpledb/utils/LRUCache.java
new file mode 100644
--- /dev/null	(date 1669871372463)
+++ b/lab1/src/main/java/simpledb/utils/LRUCache.java	(date 1669871372463)
@@ -0,0 +1,55 @@
+package simpledb.utils;
+
+import java.util.HashMap;
+
+/**
+ * @author zhangjiajun
+ * @date 2022/12/1 12:54
+ * @description
+ */
+public class LRUCache<K,V> {
+    public class lruNode{
+        private K key;
+        private V value;
+        private lruNode next;
+        private lruNode prev;
+        public lruNode(K key, V value){
+            this.key = key;
+            this.value = value;
+        }
+
+        public lruNode(){}
+
+        public void setNext(lruNode next){
+            this.next = next;
+        }
+        public void setPrev(lruNode prev){
+            this.prev = prev;
+        }
+        public void setKey(K key){
+            this.key = key;
+        }
+        public void setValue(V value){
+            this.value = value;
+        }
+        public K getKey(){
+            return key;
+        }
+        public V getValue(){
+            return value;
+        }
+        public lruNode getNext(){return next;}
+        public lruNode getPrev(){return prev;}
+    }
+    private HashMap<K,V> map;
+    private lruNode head,tail;
+    private int capacity;
+    private int size;
+    public LRUCache(int capacity){
+        map = new HashMap<>();
+        this.capacity = capacity;
+        size = 0;
+        head = new lruNode();
+        tail = new lruNode();
+    }
+}
